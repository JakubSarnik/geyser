We base our implementation mainly on Efficient Implementation of Property
Directed Reachability (Een, Mischenko, Brayton) and Comparing Different
Variants of the IC3 Algorithm for Hardware Model Checking (Griggio, Roveri).

Given a transition system S = <X, Y, I(X), T(X, Y, X')> and an error formula
E(X, Y) [describing that input Y in state X is bad; note that the error formula
might depend on Y in Aiger], we store a trace

  F_0, F_1, ..., F_k, F_inf,

where each F_i is a set of cubes blocked at step i, but not at step i + 1. Note
that we can reconstruct the original meaning of the trace

  R_0, R_1, ..., R_k

in IC3 by

  R_i = -F_i /\ -F_{i + 1} /\ ... /\ -F_k /\ -F_inf
  (and R_0 = I).

Following Een et al., F_inf is a special set which contains those cubes that
have been proven unreachable in any number of steps. The trace is implemented
as a vector storing F_0, ..., F_inf in order.

The pseudocode is as follows:

pdr() -> result:
  F.push_back() # Create (empty) F_inf at the back of F
  push_frame() # Create (empty) F_0 at the start of F (i.e. F = [F_0, F_inf])

  # Note that k is |F| - 1

  loop:
    while SAT( R[k] /\ E ):
      s = model( R[k] /\ E )

      if solve_obligation( < s, k > ) == counterexample:
        # This needs to be done with some additional bookkeeping, like storing
        # predecessor inputs in proof obligations as well?
        return counterexample

    push_frame() # Create (empty) F_{k + 1}

    if propagate() == invariant_found:
      return ok


solve_obligation( < s, k > : cube * int ) -> result:
  # Minimum priority queue of proof obligations, ordered by frame
  Q = minimum_queue()
  Q.add( < s, k > )

  while ( |Q| > 0 ):
    < c, i > = Q.pop_minimum()

    if i == 0:
      return counterexample # We have backtraced to an initial state!

    # If we have already seen this cube, do not return to it
    if is_already_blocked( < c, i > ):
      continue

    # Note that at this point, c is guaranteed not to intersect with the
    # initial states

    if SAT( R[ i - 1 ] /\ -c /\ T /\ c' ):
      # c has a predecessor d in R[ i - 1 ]
      d = model( R[ i - 1 ] /\ -c /\ T /\ c' )

      # Generalize a full model to a shorter cube
      e = generalize_predecessor( d )

      # Focus now on blocking e one step closer to the initial states
      Q.add( < e, i - 1 > )

      # After that is done, return back to c, try a different predecessor
      Q.add( < c, i > )

    else:
      # There is no predecessor in R[ i - 1 ] of any state in c
      # Generalize cube c to block more states
      < d, j > = generalize_inductive( c, i )

      # Note that Een et al.'s generalization is quite a bit more involved
      # here, and we need to access the unsat core of the SAT call.
      # TODO: Investigate this more and how it interacts with F_inf.
      #       Do we even want F_inf?

      add_blocked_at( d, j )

      # This is not necessary according to Een et al., but it apparently
      # improves performance.
      # TODO: Investigate
      if i < k && j != inf:
        Q.add( < c, j > )


push_frame():
  TODO


propagate():
  TODO


is_already_blocked( < c, i > : cube * int ) -> bool:
  TODO


add_blocked_at( c : cube, i : int ):
  TODO


# We found that c is a predecessor state (i.e. a full cube) of some other cube.
# Generalize (e.g. using ternary simulation or a SAT based approach) to a
# smaller cube.
generalize_predecessor( s : cube ) -> cube:
  TODO


generalize_inductive( s : cube, i : int ) -> cube:
  TODO


TODO: Also investigate how to best interact with the solver. Activation
      literals for each frame? Relative induction using constrain clauses?
      When to reset?...